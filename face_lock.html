<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì–¼êµ´ ì¸ì‹ ì ê¸ˆ/í•´ì œ</title>
    
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root { --primary: #4CAF50; --primary-dark: #388E3C; --danger: #f44336; --info: #2196F3; --bg: #f0f2f5; --card: white; --text: #333; --border: #ddd; }
        body { font-family: 'Noto Sans KR', sans-serif; background-color: var(--bg); }
        .btn { padding: 10px 20px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s; margin-right: 10px; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .btn:disabled { background-color: #9ca3af; cursor: not-allowed; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover:not(:disabled) { background: var(--primary-dark); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3); }
        .btn-danger { background: var(--danger); color: white; }
        .btn-danger:hover { background: #d32f2f; }
        .btn-info { background: var(--info); color: white; }
        .btn-info:hover { background: #1976D2; }
        .status { display: inline-block; padding: 6px 12px; border-radius: 20px; font-size: 13px; font-weight: 600; margin-left: 10px; }
        .status.connected { background: #e8f5e9; color: #2e7d32; }
        .status.disconnected { background: #ffebee; color: #c62828; }
        #canvas-container { position: relative; width: 100%; max-width: 640px; aspect-ratio: 4 / 3; }
        #video, #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .input-box { border: 1px solid var(--border); padding: 10px; border-radius: 8px; width:100%; }
        .user-list-item { background: #e8f5e9; padding: 8px 12px; border-radius: 20px; font-weight: 500; display: flex; align-items: center; justify-content: space-between; }
        .user-list-item button { background: var(--danger); color: white; border-radius: 50%; width: 24px; height: 24px; line-height: 24px; text-align: center; border:none; cursor:pointer; }
    </style>
</head>
<body class="p-4">
    <div class="max-w-4xl w-full mx-auto p-4 md:p-6 bg-white rounded-2xl shadow-lg">
        <header class="relative text-center mb-6 p-5 rounded-2xl shadow-md bg-white">
             <a href="FACE_AllinOne4MCU.html" title="ì–¼êµ´ì¸ì‹ ì˜¬ì¸ì›ìœ¼ë¡œ ëŒì•„ê°€ê¸°" class="absolute left-4 md:left-6 top-1/2 -translate-y-1/2 p-2 rounded-full hover:bg-gray-100 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M11 15l-3-3m0 0l3-3m-3 3h8M3 12a9 9 0 1118 0 9 9 0 01-18 0z" />
                </svg>
            </a>
            <h1 class="text-3xl md:text-4xl font-bold" style="color: var(--primary);">ğŸ” ì–¼êµ´ ì¸ì‹ ì ê¸ˆ/í•´ì œ</h1>
            <p class="text-gray-500 mt-2">face-api.jsë¥¼ í™œìš©í•œ ì›¹ ê¸°ë°˜ ì–¼êµ´ ì¸ì¦ ì‹œìŠ¤í…œ</p>
        </header>

        <main class="flex flex-col items-center">
            <div id="canvas-container" class="rounded-xl overflow-hidden shadow-md border-2 border-gray-200 bg-black flex justify-center items-center">
                <video id="video" autoplay muted playsinline></video>
                <canvas id="canvas"></canvas>
                <div id="loader" class="loader"></div>
                <div id="loading-text" class="text-white absolute mt-20">AI ëª¨ë¸ ë¡œë”© ì¤‘...</div>
            </div>

             <div id="result-display" class="mt-4 text-2xl font-bold text-center h-8"></div>
            
            <div class="w-full max-w-2xl mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="card p-4 bg-gray-50 rounded-lg">
                    <h3 class="text-lg font-bold mb-3">ğŸ‘¨â€ğŸ“ ì–¼êµ´ í•™ìŠµ</h3>
                    <div class="flex items-center gap-2 mb-3">
                        <input type="text" id="name-input" placeholder="ì´ë¦„ ì…ë ¥ (ì˜ë¬¸)" class="input-box flex-grow">
                        <button id="register-btn" class="btn btn-info" style="margin: 0;">ë“±ë¡</button>
                    </div>
                    <div id="registered-users-list" class="space-y-2 mb-3"></div>
                    <button id="clear-btn" class="btn btn-danger w-full" style="margin: 0;">ëª¨ë“  ì–¼êµ´ ì‚­ì œ</button>
                </div>

                <div class="card p-4 bg-gray-50 rounded-lg">
                    <h3 class="text-lg font-bold mb-3">ğŸ”Œ ì—°ê²° ì„¤ì •</h3>
                    <div class="input-group mb-4">
                        <label for="ble-device-type" class="text-sm font-medium text-gray-700">ë¸”ë£¨íˆ¬ìŠ¤ ì¥ì¹˜ ìœ í˜•</label>
                        <select id="ble-device-type" class="w-full mt-1 p-2 border border-gray-300 rounded-md">
                            <option value="microbit">ë§ˆì´í¬ë¡œë¹„íŠ¸ (ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰)</option>                    
                            <option value="generic">ì¼ë°˜ UART ì¥ì¹˜ (Arduino, ESP32 ë“±)</option>
                        </select>
                    </div>
                    <div class="flex flex-wrap">
                        <button id="connectSerialBtn" class="btn btn-primary">ì‹œë¦¬ì–¼ ì—°ê²°</button>
                        <button id="disconnectSerialBtn" class="btn btn-danger" disabled>í•´ì œ</button>
                        <button id="connectBleBtn" class="btn btn-primary">ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²°</button>
                        <button id="disconnectBleBtn" class="btn btn-danger">í•´ì œ</button>
                    </div>
                    <span id="connectionStatus" class="status disconnected">ì—°ê²° ì•ˆë¨</span>
                </div>
            </div>
        </main>
    </div>

    <script>
        const ui = {
            video: document.getElementById('video'),
            canvas: document.getElementById('canvas'),
            loader: document.getElementById('loader'),
            loadingText: document.getElementById('loading-text'),
            nameInput: document.getElementById('name-input'),
            registerBtn: document.getElementById('register-btn'),
            clearBtn: document.getElementById('clear-btn'),
            registeredUsersList: document.getElementById('registered-users-list'),
            resultDisplay: document.getElementById('result-display'),
            connectSerialBtn: document.getElementById('connectSerialBtn'),
            disconnectSerialBtn: document.getElementById('disconnectSerialBtn'),
            connectBleBtn: document.getElementById('connectBleBtn'),
            disconnectBleBtn: document.getElementById('disconnectBleBtn'),
            connectionStatus: document.getElementById('connectionStatus'),
            bleDeviceType: document.getElementById('ble-device-type')
        };

        const CONFIG = {
            SERIAL_BAUD_RATE: 9600,
            BLE_SERVICE_UUID: '6e400001-b5a3-f393-e0a9-e50e24dcca9e',
            BLE_CHARACTERISTIC_UUID: '6e400003-b5a3-f393-e0a9-e50e24dcca9e',
            RECOGNITION_THRESHOLD: 0.4, 
            MAX_USERS: 5,
            LOCAL_STORAGE_KEY: 'faceLockRegisteredUsers'
        };

        const ConnectionManager = {
            port: null, writer: null,
            bleDevice: null, bleCharacteristic: null,
            
            async sendToMCU(data) {
                const dataToSend = data + '\n';
                if (this.port?.writable) {
                    try {
                        this.writer = this.port.writable.getWriter();
                        await this.writer.write(new TextEncoder().encode(dataToSend));
                    } catch (e) { console.error("ì‹œë¦¬ì–¼ ë°ì´í„° ì „ì†¡ ì˜¤ë¥˜:", e); } 
                    finally { if (this.writer) { this.writer.releaseLock(); this.writer = null; } }
                }
                if (this.bleCharacteristic) {
                    try { await this.bleCharacteristic.writeValue(new TextEncoder().encode(dataToSend)); } 
                    catch (e) { console.error("BLE ë°ì´í„° ì „ì†¡ ì˜¤ë¥˜:", e); }
                }
            },
            
            async connectSerial() { 
                try {
                    const port = await navigator.serial.requestPort(); 
                    await port.open({ baudRate: CONFIG.SERIAL_BAUD_RATE }); 
                    this.port = port;
                    this.updateConnectionStatus(true, 'ì‹œë¦¬ì–¼');
                } catch(e) {
                    if (e.name !== 'NotFoundError') alert(`ì‹œë¦¬ì–¼ ì—°ê²° ì˜¤ë¥˜: ${e.message}`);
                } 
            },

            async disconnectSerial() { 
                if (!this.port) return;
                try { if (this.port.readable || this.port.writable) await this.port.close(); } 
                catch (e) { console.error('í¬íŠ¸ ë‹«ê¸° ì¤‘ ì˜¤ë¥˜:', e); } 
                finally { this.port = null; this.updateConnectionStatus(false); }
            },

            async connectBLE() {
                const devType = ui.bleDeviceType.value;
                const opts = devType === 'microbit' ? {filters:[{namePrefix:"BBC micro:bit"}], optionalServices:[CONFIG.BLE_SERVICE_UUID]} : {filters:[{services:[CONFIG.BLE_SERVICE_UUID]}]};
                try {
                    this.bleDevice = await navigator.bluetooth.requestDevice(opts);
                    this.bleDevice.addEventListener('gattserverdisconnected', () => this.updateConnectionStatus(false));
                    const server = await this.bleDevice.gatt.connect();
                    const service = await server.getPrimaryService(CONFIG.BLE_SERVICE_UUID);
                    this.bleCharacteristic = await service.getCharacteristic(CONFIG.BLE_CHARACTERISTIC_UUID);
                    this.updateConnectionStatus(true, 'ë¸”ë£¨íˆ¬ìŠ¤'); 
                    alert('ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ì„±ê³µ!');
                } catch(e) {
                    alert(`ë¸”ë£¨íˆ¬ìŠ¤ ì—°ê²° ì˜¤ë¥˜: ${e.message}`); 
                    this.updateConnectionStatus(false);
                }
            },

            disconnectBLE() { 
                if(this.bleDevice?.gatt.connected){
                    this.bleDevice.gatt.disconnect();
                } 
            },

            updateConnectionStatus(connected, type = '') {
                ui.connectionStatus.textContent = connected ? `${type} ì—°ê²°ë¨` : 'ì—°ê²° ì•ˆë¨';
                ui.connectionStatus.className = `status ${connected ? 'connected' : 'disconnected'}`;
                if (type.toLowerCase().includes('serial') || type.toLowerCase().includes('ì‹œë¦¬ì–¼')) {
                    ui.connectSerialBtn.disabled = connected;
                    ui.disconnectSerialBtn.disabled = !connected;
                }
            }
        };


        const FaceLockApp = {
            registeredUsers: [],
            faceMatcher: null,
            modelsLoaded: false, 

            async init() {
                this.setupEventListeners();
                this.startWebcam();
                await this.loadModels();
                this.loadRegisteredFaces();
            },

            setupEventListeners() {
                ui.registerBtn.addEventListener('click', () => this.handleRegistration());
                ui.clearBtn.addEventListener('click', () => this.handleClear());
                ui.connectSerialBtn.addEventListener('click', () => ConnectionManager.connectSerial());
                ui.disconnectSerialBtn.addEventListener('click', () => ConnectionManager.disconnectSerial());
                ui.connectBleBtn.addEventListener('click', () => ConnectionManager.connectBLE());
                ui.disconnectBleBtn.addEventListener('click', () => ConnectionManager.disconnectBLE());
            },

            async loadModels() {
                // *** ì—¬ê¸°ê°€ ìµœì¢… ìˆ˜ì •ëœ ë¶€ë¶„ ***
                const MODEL_URL = './weights'; 
                try {
                    await Promise.all([
                        faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                        faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                        faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL)
                    ]);
                    this.modelsLoaded = true;
                    ui.loader.style.display = 'none';
                    ui.loadingText.style.display = 'none';
                } catch (error) {
                    ui.loader.style.display = 'none';
                    ui.loadingText.innerHTML = "ëª¨ë¸ ë¡œë”© ì‹¤íŒ¨.<br>'weights' í´ë”ê°€ html íŒŒì¼ ì˜†ì— ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.";
                    console.error("AI ëª¨ë¸ ë¡œë”© ì˜¤ë¥˜:", error);
                }
            },

            startWebcam() {
                navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                    .then(stream => {
                        ui.video.srcObject = stream;
                        ui.video.addEventListener('play', () => this.startRecognitionLoop());
                    })
                    .catch(err => {
                        alert("ì›¹ìº ì„ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
                        ui.loader.style.display = 'none';
                        ui.loadingText.textContent = "ì¹´ë©”ë¼ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.";
                    });
            },

            loadRegisteredFaces() {
                const data = localStorage.getItem(CONFIG.LOCAL_STORAGE_KEY);
                if (data) {
                    const parsedData = JSON.parse(data);
                    this.registeredUsers = parsedData.map(user => 
                        new faceapi.LabeledFaceDescriptors(user.label, user.descriptors.map(d => new Float32Array(d)))
                    );
                }
                this.updateFaceMatcher();
                this.updateRegisteredUsersUI();
            },

            saveRegisteredFaces() {
                const dataToSave = this.registeredUsers.map(user => ({
                    label: user.label,
                    descriptors: user.descriptors.map(d => Array.from(d))
                }));
                localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            },
            
            updateRegisteredUsersUI() {
                ui.registeredUsersList.innerHTML = '';
                this.registeredUsers.forEach(user => {
                    const userEl = document.createElement('div');
                    userEl.className = 'user-list-item';
                    userEl.innerHTML = `<span>ğŸ‘¤ ${user.label}</span><button data-label="${user.label}">&times;</button>`;
                    ui.registeredUsersList.appendChild(userEl);
                });
                ui.registeredUsersList.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', (e) => this.removeUser(e.target.dataset.label));
                });
            },

            async handleRegistration() {
                if (!this.modelsLoaded) {
                    alert("ì•„ì§ AI ëª¨ë¸ì´ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.");
                    return;
                }
                const name = ui.nameInput.value.trim();
                if (!name) {
                    alert("ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
                    return;
                }
                if (this.registeredUsers.length >= CONFIG.MAX_USERS) {
                    alert(`ìµœëŒ€ ${CONFIG.MAX_USERS}ëª…ê¹Œì§€ë§Œ ë“±ë¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
                    return;
                }
                if (this.registeredUsers.find(user => user.label === name)) {
                    alert("ì´ë¯¸ ë“±ë¡ëœ ì´ë¦„ì…ë‹ˆë‹¤.");
                    return;
                }

                ui.resultDisplay.textContent = 'ì–¼êµ´ì„ ì •ë©´ìœ¼ë¡œ ë³´ì—¬ì£¼ì„¸ìš”...';
                const detections = await faceapi.detectSingleFace(ui.video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptor();

                if (!detections) {
                    alert("ì–¼êµ´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë°ì€ ê³³ì—ì„œ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.");
                    ui.resultDisplay.textContent = '';
                    return;
                }

                const newDescriptor = new faceapi.LabeledFaceDescriptors(name, [detections.descriptor]);
                this.registeredUsers.push(newDescriptor);
                
                this.saveRegisteredFaces();
                this.updateFaceMatcher();
                this.updateRegisteredUsersUI();

                ui.nameInput.value = '';
                ui.resultDisplay.textContent = `${name}ë‹˜ ë“±ë¡ ì™„ë£Œ!`;
                setTimeout(() => ui.resultDisplay.textContent = '', 2000);
            },
            
            removeUser(labelToRemove) {
                this.registeredUsers = this.registeredUsers.filter(user => user.label !== labelToRemove);
                this.saveRegisteredFaces();
                this.updateFaceMatcher();
                this.updateRegisteredUsersUI();
            },

            handleClear() {
                if(confirm("ì •ë§ë¡œ ëª¨ë“  ë“±ë¡ëœ ì–¼êµ´ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                    this.registeredUsers = [];
                    localStorage.removeItem(CONFIG.LOCAL_STORAGE_KEY);
                    this.updateFaceMatcher();
                    this.updateRegisteredUsersUI();
                }
            },
            
            updateFaceMatcher() {
                if (this.registeredUsers.length > 0) {
                    this.faceMatcher = new faceapi.FaceMatcher(this.registeredUsers, CONFIG.RECOGNITION_THRESHOLD);
                } else {
                    this.faceMatcher = null;
                }
            },

            startRecognitionLoop() {
                const displaySize = { width: ui.video.clientWidth, height: ui.video.clientHeight };
                faceapi.matchDimensions(ui.canvas, displaySize);

                setInterval(async () => {
                    if (!this.modelsLoaded) {
                        return;
                    }

                    const detections = await faceapi.detectAllFaces(ui.video, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceDescriptors();
                    const resizedDetections = faceapi.resizeResults(detections, displaySize);
                    
                    ui.canvas.getContext('2d').clearRect(0, 0, ui.canvas.width, ui.canvas.height);
                    
                    if (!this.faceMatcher) {
                        ui.resultDisplay.textContent = "ì–¼êµ´ì„ ë¨¼ì € ë“±ë¡í•´ì£¼ì„¸ìš”.";
                        return;
                    }

                    if (resizedDetections.length > 0) {
                        const results = resizedDetections.map(d => this.faceMatcher.findBestMatch(d.descriptor));
                        
                        let recognized = false;
                        results.forEach((result, i) => {
                            const box = resizedDetections[i].detection.box;
                            const drawBox = new faceapi.draw.DrawBox(box, { label: result.toString() });
                            drawBox.draw(ui.canvas);

                            if (result.label !== 'unknown') {
                                ui.resultDisplay.innerHTML = `âœ… <span style="color:var(--primary)">${result.label}</span>ë‹˜, ì¸ì¦ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                                ConnectionManager.sendToMCU('1');
                                recognized = true;
                            }
});

                        if (!recognized) {
                           ui.resultDisplay.innerHTML = 'âŒ ë“±ë¡ë˜ì§€ ì•Šì€ ì‚¬ìš©ìì…ë‹ˆë‹¤.';
                           ConnectionManager.sendToMCU('0');
                        }
                    } else {
                        ui.resultDisplay.textContent = 'ì¹´ë©”ë¼ ì•ì—ì„œ ì–¼êµ´ì„ ë³´ì—¬ì£¼ì„¸ìš”.';
                    }
                }, 200);
            }
        };

        document.addEventListener('DOMContentLoaded', () => FaceLockApp.init());
    </script>
</body>
</html>